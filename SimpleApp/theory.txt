Lecture 3

Тестирование нашего проекта


Если мы хотим протестировать слой, который отвечает за работу с данными (репозитории), то:

Не следует использовать для тестирования ту же базу данных (файл), которая используется в основном проекте
Вместо этого мы будем делать временный файл (временную базу данных) перед каждым тестом и будем сразу удалять его после каждого теста
Почему? Мы не хотим, чтобы тест повредил или как-либо изменил те данные, которые нам важны в основном проекте
Если мы с вами хотим протестировать сервис, который зависит от другого репозитория, какую реализацию репозитория нам нужно подставить?\

Правильный подход - создать временную, фэйковую, заглушку, mock-реализацию для конкретного теста.
Для этой фэйковой реализации мы явно опишем какие значения должен возвращать тот или иной метод.
Такой подход называется mock-тестированием и используется в Unit/Модульных тестах.
Мы хотим проверить наш класс, независимо от того, как работают другие, чтобы точно понять причину ошибки.
@BeforeEach - аннотация JUnit, которой мы можем пометить метод, запускаемый перед каждым тестом автоматически

@AfterEach - аннотация JUnit, которой мы можем пометить метод, запускаемый после каждого теста

@Nested - аннотация, которой можно помечать вложенные классы с тестами

Вложенные классы используем для группировки тестов, каждый вложенный класс может содержать тесты для конкретного метода
Заметки
Arrays.asList(T ... a) - создает ArrayList на основе набора объектов.
Mockito - библиотека для Mock-тестирования.
.class - получение описания типа какого-либо класса, используется, когда Java нужно проверить, принадлежит ли какой-либо объект какому-то классу.
stubbing - процесс, когда мы явно прописываем реализацию какой-либо заглушки
verify - подходит, когда нужно проверить, был ли вызван void-метод
Словарик

before each - перед каждым
after each - после каждого
temp - временный
exists - существует (содержится)
nested - внутренний
expected - ожидаемый (тот результат, который мы ожидаем)
actual - актуальный (тот результат, который нам пришел по факту)
replace underscores - заменить нижние подчеркивания


Lecture 3.
Слабая связь между компонентами
Благодаря тому, что у нас классы ссылаются на интерфейсы, мы можем менять конфигурацию приложения в Main, подставляя разные реализации одних и тех же интерфейсов

В реальных приложениях компонентов может быть достаточно много, например:

Слой сервисов для обычного пользователя и администратора
Различные виды валидаторов
Куча контроллеров на разные запросы
Разные репозитории и разные типы репозиториев\
В приложениях, где таких компонентов много становится трудно самостоятельно создавать объекты и связывать их между собой (как в примере Main)

Spring
Реализует подход IoC/DI
Основные понятия
Bean\Бин - центральное понятие Spring. Бин - это просто объект какого-либо класса, который "управляется" Spring-ом (Spring management)
Когда обычный объект называют "бином Spring"? Когда этот объект был создан с использованием Spring.
Мы можем создать класс (как правило, его помечают аннотацией @Configuration) в котором мы опишем "бины".
Каждый бин характеризуется своим "названием/id" и классом, на основе которого он создан.
В случае, если мы создаем бин с помощью метода, например:
    @Bean
    public PasswordValidator passwordValidatorNotEmpty() {
        return new PasswordNotEmptyValidatorImpl();
    }
То здесь id-бина - это название метода - passwordValidatorNotEmpty
А класс/тип бина - PasswordValidator
Чтобы воспользоваться этим бином, необходимо его погрузить в Spring Context, а именно:
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
После того, как мы погрузили его в Spring Context, мы можем его оттуда вытащить по id и типу:
PasswordValidator passwordValidator = applicationContext.getBean("passwordValidatorRegex", PasswordValidator.class);
Пройдем заново
В Main мы создавали экземпляры каждого класса и связывали их между собой.
В Main2 мы обратились к контейнеру Spring (Spring Context) и попросили у него бин с типом UsersController
Данный бин к нам пришел с зависимостью на UsersService,а тот, в свою очередь зависит от всех других бинов.
Чтобы бины были в контейнере, я создал класс AppConfig в котором перечислил все бины, которые мне нужны.
Подход, когда логика создания компонентов приложения и их связывания выносится в отдельный модуль - называется Inversion of Control (IoC).
Бин - это просто объект, компонент приложения, экземпляр какого-либо класса, просто он находится внутри контейнера/контекста Spring.
Как было сказано, у бина есть тип и название (id).
Есть множество способов объявления бина, один из них - аннотация @Bean
@Bean - аннотация, которой мы помечаем метод, результатом работы которого является какой-либо бин.

@Bean
public PasswordValidator passwordValidatorNotEmpty() {
    return new PasswordNotEmptyValidatorImpl();
}

passwordValidatorNotEmpty - будущее название/id вашего бина типа PasswordValidator
внутри метода описываем логику создания нашего бина, в конце обязательно return
id-бина может быть абсолютно любым, главное - уникальным:
@Bean
public PasswordValidator xyz() {
    return new PasswordNotEmptyValidatorImpl();
}

В метод, который помечен аннотацией @Bean можно подставить другие бины в параметрах метода.
Название параметра должно соответствовать названию бина, если у вас несколько бинов одинакового типа.
Если бин по такому типу только один - на название параметра все равно.
Итоги
Положить бин в контейнер можно с помощью аннотации @Bean
Получить бин из контейнера можно с помощью:
applicationContext.getBean(ТипНужногоБина.class)
applicationContext.getBean(Id-нужного-бина, ТипНужногоБина.class)